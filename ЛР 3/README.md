# README.md

---

## Задание 1
Модернизируйте калькулятор из задач 1.2 и 1.4 Лабораторной работы
№ 2. Добавьте к калькулятору такую настройку как точность вычислений, которая передаётся в виде keyword параметра tolerance со
значением по умолчанию 1e−6. На основе переданного значения этого
параметра извлеките с помощью вычислений порядок этого значения
(например 6 для 1e−6) в виде отдельной функции convert_precision,
вызываемой из calculate. Задокументируйте convert_precision и
дополните документацию к calculate в коде. Извлечённый порядок
используйте для округления итогового результата в функции calculate.
Покройте (напишите) дополнительными тестами convert_precision
и calculate в связи с появлением tolerance с помощью пакета pytest
или стандартных unittest Python по выбору.

**Комментарий к основной программе:** Почти вся программа уже была написана в 1.2 ЛР № 2, поэтому она сложностей уже не вызывала. Сложность была только в извлечении порядка точности, а именно в выборе метода этого извлечения и его грамотной работы в целом. Для извлечения знака точности, саму точность преобразовали в строку и далее уже из строки выделялся знак. Также был учтен вариант точности вида (0.01 и 0.001)

```
    if 'e' in h or 'E' in h:
        part, order = h.split('e') if 'e' in h else h.split('E')

        return abs(int(order))

    elif '.' in h:
        part1, part2 = h.split('.')

        return len(part2)
```

**Результат основной программы:** 

![code1](https://github.com/MelnikNO/programming-2/blob/main/Screen/LR3_1.png)


**Комментарий к тестовой программе:** Программа не вызвала сложность, так как была написана в 1.4 ЛР № 2 

**Результат тестовой программы (unit-тест):** 

![code1](https://github.com/MelnikNO/programming-2/blob/main/Screen/L3_1_unittest.png)

**Результат тестовой программы (pytest):** 

![code1](https://github.com/MelnikNO/programming-2/blob/main/Screen/LR3_1_pytest.png)

---

## Задание 2
Модернизируйте калькулятор из задачи 1.1. Добавьте переменное количество неименоманных аргументов (операндов, ∗args) после параметра action и перед keyword параметром tolerance. К списку
поддерживаемых действий добавьте вычисление таких величин как
среднее значение (medium), дисперсия (variance), стандартное отклонение (std_deviation), медиана (median, q2, второй квартиль) и межквартильный размах (q3 - q1, разница третьего и первого квартилей).
Покройте новые реализованные функции и функцию calculate дополнительными юнит-тестами.

**Комментарий к основной программе:** Задание и пррграмма в целом не вызвало сложностей. Так как частично написано в задании 1.2 ЛР2 и 1.1. Все новые операции были сделаны вручную, без использования библиотек и других методов, для большего понимания их работы. Единственная заминка была при написании межквартального размаха, а именно учет четного и нечетного количества данных для каждого квартиля.

**Результат основной программы:** 


**Комментарий к тестовой программе:** Программа не вызвала сложность, так как была написана в 1.4 ЛР № 2 

**Результат тестовой программы (unit-тест):** 

**Результат тестовой программы (pytest):** 
