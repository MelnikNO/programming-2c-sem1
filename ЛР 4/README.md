# README.md


## КОМПЛЕКТ 1
## Задание 1
Написать функцию two_sum, которая возвращает кортеж из двух ин-
дексов элементов списка lst, таких что сумма элементов по этим ин-
дексам равна переменной target, Элемент по индексу может быть
выбран лишь единожды, значения в списке могут повторяться. Если в
списке встречается больше чем два индекса, подходящих под условие
- вернуть наименьшие из всех. Элементы находятся в списке в про-
извольном порядке. Алгоритм на двух циклах, сложность O(n^2). При-
мер кода-заготовки на replit.com: https://replit.com/@zhukov/
Appropriate,dealistic/aw#main.p.
Пример использования:
lst = [1, 2, 3, 4, 5, 6, 7, 8, 9]
target = 8
result = two_sum(lst, target)
print(result)
Результат:
(0, 6)

**Комментарий:** Написание кода не вызвало особых сложностей, главное надо было учесть - поиск наименьшой пары и алгоритм со сложностью O(n^2) (алгоритм на двух циклах)

```
    res = []
    for i in range(len(lst)):
        for j in range(i + 1, len(lst)):
            if lst[i] + lst[j] == target:
                res = [i, j]
                return res
    return res
```

**Результат программы:**

![code11](https://github.com/MelnikNO/programming-2/blob/main/Screen/lr4_code1_1.png)

---

## Задание 2
Усовершенствуйте предыдущую задачу ??, добавив функцию
two_sum_hashed(lst, target) так, чтобы сложность алгоритма была
ниже: O(n) или O(n · log(n)).

**Комментарий:** Программа вызвала небольшие трудности, а именно в том, чтобы сложность алгоритма была по требованию задачи, но она была решена

```
    res = {}
    mi = None

    for i, num in enumerate(lst):
        c = target - num
        if c in res:
            if mi is None or (res[c], i) < mi:
                mi = (res[c], i)

        res[num] = i

    return mi
```

**Результат программы:**

![code12](https://github.com/MelnikNO/programming-2/blob/main/Screen/lr4_code1_2.png)

---

## Задание 3
Усовершенствуйте предыдущую задачу 1.2, добавив функцию , ко-
торая возвращает все наборы индексов, удовлетворяющих условию
суммы target. Пример использования:
lst = [1, 2, 3, 4, 5, 6, 7, 8, 9]
target = 8
result = two_sum_hashed_all(lst, target)
print(result)

Результат:
[(0,6), (1,5), (2,4)]

**Комментарий:** Программа не вызвала сложностей, т.к. основная суть была разобрана на занятиях.

**Результат программы:**

![code13](https://github.com/MelnikNO/programming-2/blob/main/Screen/lr4_code1_3.png)

---

## Задание 4
Повторите или изучите понятие мемоизации в Python. Реализуйте с
помощью мемоизации и рекурсии вычисление чисел Фибоначчи сна-
чала рукаки с помощью вручную добавленого к рекурсивной функции
словаря с ранее вычисленными числами Фибоначчи, а затем с помо-
щью декоратора @cache из стандартного модуля Python functools.

**Комментарий:** Программа не вызвала сложностей, т.к. былаа полностью разобрана на лабораторных занятиях

**Результат программы:** 

![code14](https://github.com/MelnikNO/programming-2/blob/main/Screen/lr4_code1_4.png)

---

## КОМПЛЕКТ 2
## Задание 1
Отправка почты через smtplib.

**Комментарий:** Программа не вызвала в целом сложностей, т.к. была разобрана в курсе moodle. Но, попытка все-таки попробовать использовать почту gmail и yandex не увенчалась успехом (т.к. почту mail до последнего момента не хотелось заводить), поэтому пришлось заводить почту mail.ru и пароль, который можно использовать, после этого все заработало 

**Результат программы:**

![code21](https://github.com/MelnikNO/programming-2/blob/main/Screen/lr4_code2_1.jpg)

---

## Задание 2
Парсинг сайта погоды (wheather HTML parsing) на google.com и/или на простом сайте wttrin с помощью BeautifulSoup (v4).

**Комментарий:** Программа вызвала большие сложности, т.к. парсинг не происходил по двум ссылкам из задания. После долгой и многоразовой попытки, получилось произвести частичный парсинг погоды библиотекой (программа выдает результат, но после происходит ошибка)

**Результат программы:** 

![code22](https://github.com/MelnikNO/programming-2/blob/main/Screen/lr4_code2_2.png)

---

## Задание 3
С помощью бибилиотеки matplotlib вывести два окна с графиками
функций по личному выбору. В одном окне два графика двух разных
функций. В другом окне - один график ещё одной функции.

**Комментарий:** Программа не вызвало сложностей, т.к. для выполнения надо было вспомнить библиотеку matplotlib и аккуратно прописать каждое окно с графиками, используя некоторые дополнительные функции (например, отображение легенды и сетки)

**Результат программы:**

![code23](https://github.com/MelnikNO/programming-2/blob/main/Screen/lr4_code2_3.png)
