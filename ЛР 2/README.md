# README.md

## Задание 1
Создайте простое замыкание (closure) в виде внутренней (вложенной) функции внутри обычной функции. Внутренняя функция (замыкание, closure) должна использовать переменные и аргументы обычной функции, в которую она вложена. Внутри внутренней функции (closure) распечатайте переданные аргументы в терминале. Верните вложенную функцию из обычной функции с помощью выражения return. 

**Комментарий:** Сложностей данное задание почти не вызвало, т.к. главное надо было понять суть замыкания (кратко замыкание - это функция, которая пишется внутри внешней функции и может иметь доступ к переменным внешней функции). Также надо было не забыть про правильность вызова внешней функции (чтобы при запуске выводил результат программы а не ссылку на внутреннюю функцию)

**Результат программы:**

![code1](https://github.com/MelnikNO/programming-2/blob/main/Screen/lr2_code1.png)

---

## Задание 2
Изучите на примерах в интернете, что такое closure и и как их применять для создания простого декоратора (decorator) с @-синтаксисом в Python. Модернизируйте калькулятор из задачи 3.1 лабораторной работы №1. Декорируйте вашу функцию calculate. В соответствующем декорирующем замыкании, в сlosure, то есть во внутренней функции используйте простое логирование (стандартный модуль Python logging). Сделайте логирование внутри замыкания до вызова вашей функции calculate(operand1, operand2, action), в котором логируется информация о том какие операнды и какая арифметическая операция собираются поступить на вход функции calculate(operand1, operand2, action). Затем внутри того же closure следует сам вызов функции calculate(...). А затем, после этого вызова должно быть снова логирование, но уже с результатом выполнения вычисления, проделанного в этой функции. 

**Комментарий к основной программе:** В этом задании были сложности. Самая главная - декорирование и логирование (понять их суть и как это реализовывается в python).

1. *Логирование*. Импортировали модуль для использования его функций. Далее выполняем настройку базовой конфигурации, в которой пишем уровень логирования (DEBUG - чтобы записывались все сообщения этого уровня и выше). Даллее содаем объект логгера, чтобы получить имя текущего модуля:

```
import logging

logging.basicConfig(level=logging.DEBUG)

logger = logging.getLogger(__ name __)
```

2. *Декоратор*. Декоратор принимает функцию и возвращает новую функцию, которая оборачивает оригинальную функцию. Перед функции, которую нужно модифицировать, добавляем декоратор.

**Результат программы:**

![code2](https://github.com/MelnikNO/programming-2/blob/main/Screen/lr2_code2.png)

**Комментарий к тестовой программе:** Сложностей не возникло, т.к. оно из лабораторной работы № 1

**Результат программы:**

![test_code2](https://github.com/MelnikNO/programming-2/blob/main/Screen/lr2_test_code2.png)

---

## Задание 3
Изучите основы каррирования. Каррирование в самом простом варианте - это создание специализированной функции на основе более общей функции с предустановленными параметрами для этой более общей функции. Реализуйте каррирование на примере вычисления количества радиоактивного вещества N, оставшегося в некоторый 1 момент времени t от радиоактивного вещества с периодом полураспада t1/2, если изначально это количество было равно N0. Закон распада задан формулой: 
N= N_0*(1/2)^(t/t_(1/2) ) (1)
В качестве проставленного заранее параметра в данном примере должно быть значение периода полураспада t1/2, которое постоянно для каждого типа радиоактивного материала (радиоактивного изотопа химического элемента). Сделайте словарь, где в качестве колючей используются строки с символами радиоактивных изотопов, а в качестве значений им сопоставлены каррированные с характерными периодами полураспада. В основном коде вашей программы организуйте цикл по этому словарю и продемонстрируйте в нём вызовы каррированных функций с распечаткой на экране сколько вещества осталось от одного и того же N0 в некоторый момент времени t в зависимости от типа изотопа. 

**Комментарий:** Сложность была в каррировании. Именно реализация на python, не забыть, что кроме словаря с веществами и их периодами полураспада, надо создать еще один словарь для хранения функций, соответствующих каждому изотопу.

```
t1_2_elems = {"U_234": 7.74 * 10**12, "U_235": 2.22 * 10**16, "U_238": 1.41 * 10**17}
radioactive_funcs = {"U_234": None, "U_235": None, "U_238": None}
```

Далее после функции с вычислением количества радиоактивного вещества надо было не забыть про создание соответсвующих функций для соответсвующего вещества, где фиксируется период полураспада.

Следующая сложность возникла при написании цикла по словарю в основной функции. Цикл с ключами названия изотопов и функции проходит по элементам словаря, который вызывает функцию и выводит на экран результат выполненной работы с показом названия вещества и вычисления функции. 

**Результат программы:**

![code3](https://github.com/MelnikNO/programming-2/blob/main/Screen/lr2_code3.png)

---

## Задание 4
Напишите unit-тесты для калькулятора из задачи 3.1 лабораторной работы № 1 используя стандартный модуль unittest библиотеки Python. Базовый пример: https://docs.python.org/3/library/unittest.html#basic-example 
Затем перепешите теже тесты с использованием пакета pytest. Ссылка на сайт библиотеки с базовым примером: https://pytest.org/en/7.2.x/

**Комментарий к основной программе:** Сложность возникла в понятии различия unit-теста и pytest. Особых сложностей не было вызвало. Главное при написании unit-теста не забывать про классы, внутри которых функции, которые выполняют тест с указанием определенного метода (в данной задаче используется метод - assertEqual - равенство двух значений). Для pytest главное надо установить библиотеку, после установки которой можно выполнять pytest через терминал.

**Результат программы:**

Unit-тест



pytest

